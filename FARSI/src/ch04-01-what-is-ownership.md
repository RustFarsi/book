## مالکیت چیست؟
<div dir = "rtl">
از ویژگی های مهم و محوری زبان Rust، مالکیت (Ownership) است. با اینکه توضیح این مفهوم نسبتاً ساده است، اما تأثیرات عمیق و گسترده‌ای روی کل زبان دارد.

همهٔ برنامه‌ها هنگام اجرا باید نحوهٔ استفاده از حافظهٔ کامپیوتر را مدیریت کنند. بعضی زبان‌ها از GC (Garbage Collection) استفاده می‌کنند که هنگام اجرای برنامه مدام به دنبال حافظه‌هایی می‌گردد که دیگر استفاده نمی‌شوند. در برخی زبان‌های دیگر، برنامه‌نویس باید خودش به‌صورت دستی حافظه را تخصیص دهد و آزاد کند.
Rust از روش سومی استفاده می‌کند: حافظه از طریق سیستم مالکیت و مجموعه‌ای از قوانین مدیریت می‌شود که کامپایلر در زمان کامپایل آن‌ها را بررسی می‌کند. <b>هیچ‌کدام از قابلیت‌های مالکیت باعث کند شدن برنامه در زمان اجرا نمی‌شوند.</b>

از آن‌جا که مالکیت برای بسیاری از برنامه‌نویس‌ها یک مفهوم جدید است، طبیعی است که عادت کردن به آن کمی زمان ببرد. خبر خوب این است که هرچه تجربه‌ با Rust و قوانین سیستم مالکیت بیشتر شود، راحت‌تر می‌توان به‌صورت طبیعی کدی نوشت که هم ایمن باشد و هم بهینه.

وقتی مالکیت را خوب درک کنید، پایهٔ محکمی برای فهم ویژگی‌هایی خواهید داشت که Rust را منحصربه‌فرد می‌کنند. در این فصل، با بررسی چند مثال و تمرکز روی یک ساختار دادهٔ بسیار رایج یعنی رشته‌ها (Strings)، مفهوم مالکیت را یاد می‌گیرید.
</div>

> ### پشته (stack) و انباشت (heap)
>
>در بسیاری از زبان‌های برنامه‌نویسی، معمولاً لازم نیست زیاد به Stack و Heap فکر کنید. اما در یک زبان برنامه‌نویسی سیستمی مثل Rust، این‌که یک
مقدار روی stack قرار بگیرد یا روی heap، تأثیر بیشتری روی رفتار زبان دارد و
توضیح می‌دهد چرا باید بعضی تصمیم‌ها را بگیرید. در ادامهٔ این فصل، بخش‌هایی از
مفهوم مالکیت در ارتباط با stack و heap توضیح داده می‌شود، بنابراین در اینجا یک
توضیح کوتاه به‌عنوان مقدمه می‌آوریم.
>
> هم stack و هم heap بخش‌هایی از حافظه هستند که کد شما در زمان اجرا می‌تواند از
آن‌ها استفاده کند، اما ساختار متفاوتی دارند. stack مقادیر را به ترتیبی که
دریافت می‌کند ذخیره می‌کند و آن‌ها را به ترتیب معکوس خارج می‌کند. به این روش LIFO (Last In, First Out) گفته می‌شود. stack را مثل یک
دسته بشقاب در نظر بگیرید: وقتی بشقاب جدیدی اضافه می‌کنید، آن را روی بقیه
می‌گذارید و وقتی به یک بشقاب نیاز دارید، بشقاب بالایی را برمی‌دارید. اضافه یا
حذف کردن بشقاب از وسط یا پایین دسته چندان منطقی نیست! اضافه کردن داده به
stack را پوش کردن (pushing onto the stack) و خارج کردن داده از آن را
پاپ کردن (popping off the stack) می‌نامند.
>
> تمام داده‌هایی که روی stack ذخیره می‌شوند باید اندازه‌ای مشخص و ثابت داشته
باشند. داده‌هایی که اندازهٔ آن‌ها در زمان کامپایل مشخص نیست یا ممکن است تغییر
کند، باید روی heap ذخیره شوند. heap ساختار منظم‌تری ندارد: وقتی داده‌ای را روی
heap قرار می‌دهید، مقدار مشخصی فضا درخواست می‌کنید. سیستم‌عامل یک فضای خالی
به‌اندازهٔ کافی بزرگ در heap پیدا می‌کند، آن را به‌عنوان در حال استفاده علامت
می‌زند و یک اشاره‌گر (Pointer) برمی‌گرداند که آدرس آن محل است. به این فرایند
تخصیص روی انباشت (allocating on the heap) گفته می‌شود و گاهی به‌اختصار فقط
تخصیص (allocating) نامیده می‌شود. قرار دادن مقادیر روی stack «تخصیص حافظه»
محسوب نمی‌شود. چون اشاره‌گر اندازه‌ای ثابت و مشخص دارد، می‌توان خودِ اشاره‌گر
را روی stack ذخیره کرد، اما برای دسترسی به دادهٔ واقعی باید از طریق آن اشاره‌گر
عمل کرد.
>
> تصور کنید در یک رستوران نشسته‌اید. وقتی وارد می‌شوید، تعداد افراد گروهتان را
اعلام می‌کنید و پیشخدمت های رستوران یک میز خالی که برای همه جا دارد پیدا می‌کنند
و شما را به آن‌جا راهنمایی می‌کنند. اگر یکی از افراد گروه دیرتر برسد، می‌تواند
بپرسد شما کجا نشسته‌اید تا شما را پیدا کند.
>
> اضافه کردن داده به stack سریع‌تر از تخصیص روی heap است، چون سیستم‌عامل هرگز لازم
نیست دنبال جایی برای ذخیرهٔ دادهٔ جدید بگردد؛ این مکان همیشه بالای stack است.
در مقابل، تخصیص فضا روی heap کار بیشتری می‌طلبد، زیرا سیستم‌عامل ابتدا باید
فضایی به‌اندازهٔ کافی بزرگ پیدا کند و سپس کارهای مدیریتی لازم را انجام دهد تا
برای تخصیص‌های بعدی آماده باشد.
>
> دسترسی به داده‌ها در heap کندتر از دسترسی به داده‌ها در stack است، چون برای رسیدن
به آن‌ها باید از طریق یک اشاره‌گر حرکت کنید. پردازنده‌های امروزی زمانی سریع‌تر
هستند که کمتر در حافظه پرش داشته باشند. اگر به همان مثال رستوران برگردیم،
تصور کنید پیشخدمتی از چند میز مختلف سفارش می‌گیرد. کارآمدترین حالت این است که
تمام سفارش‌های یک میز را بگیرد و بعد به سراغ میز بعدی برود. این‌که یک سفارش از
میز A بگیرد، بعد یکی از میز B، دوباره از A و سپس از B، خیلی کندتر خواهد بود.
به همین شکل، پردازنده هم وقتی روی داده‌هایی کار می‌کند که به هم نزدیک‌اند
(مثل داده‌های روی stack) بهتر عمل می‌کند تا داده‌هایی که فاصلهٔ بیشتری دارند
(مثل داده‌های روی heap). علاوه بر این، تخصیص مقدار زیادی فضا روی heap نیز می‌تواند
زمان‌بر باشد.
>
> وقتی کد شما یک تابع را فراخوانی می‌کند، مقادیری که به تابع ارسال می‌شوند
(از جمله احتمالاً اشاره‌گرهایی به داده‌های روی heap) و متغیرهای محلی تابع روی
stack قرار می‌گیرند. وقتی اجرای تابع تمام می‌شود، این مقادیر از روی stack
برداشته می‌شوند.
>
> پیگیری این‌که کدام بخش‌های کد از کدام داده‌های روی heap استفاده می‌کنند، کمینه
کردن مقدار داده‌های تکراری روی heap، و پاک‌سازی داده‌های بدون استفاده روی heap تا
حافظه تمام نشود، همگی مسائلی هستند که مفهوم مالکیت آن‌ها را حل می‌کند. وقتی
مالکیت را درک کنید، دیگر لازم نیست زیاد به stack و heap فکر کنید؛ اما دانستن این‌که
مدیریت داده‌های heap دلیل اصلی وجود مالکیت است، کمک می‌کند بفهمید چرا این سیستم
به شکلی که هست کار می‌کند.

### قوانین ماکلیت

ابتدا بیایید قوانین مالکیت را بررسی کنیم. هنگام مرور مثال‌هایی که این قوانین را توضیح می‌دهند، این نکات را در ذهن داشته باشید:

* هر مقدار (value) در Rust یک متغیر دارد که به آن مالک (owner) گفته می‌شود.
* در هر لحظه فقط یک مالک می‌تواند وجود داشته باشد.
* وقتی مالک از محدودهٔ دسترسی (scope) خارج شود، مقدار مربوطه آزاد (drop) می‌شود.

### محدوده دسترسی متغیرها

در فصل ۲، یک مثال از برنامهٔ Rust را با هم بررسی کردیم. حالا که از دستورات پایه عبور کرده‌ایم، دیگر در مثال‌ها تمام کدهای مربوط به fn main() { را نمی‌آوریم. بنابراین اگر همزمان کدها را اجرا می‌کنید، باید مثال‌های بعدی را به‌صورت دستی داخل تابع main قرار بدهید. به این ترتیب، مثال‌ها خلاصه‌تر می‌شوند و می‌توانیم به‌جای کدهای تکراری و اضافی، روی جزئیات اصلی تمرکز کنیم.

به‌عنوان اولین مثال از مالکیت، می‌خواهیم به محدودهٔ دسترسی (scope) بعضی متغیرها نگاه کنیم. محدودهٔ دسترسی، بازه‌ای از برنامه است که در آن یک آیتم معتبر و قابل استفاده است. فرض کنیم متغیری داریم که به شکل زیر تعریف شده است:

```rust
let s = "hello";
```
متغیر s به یک رشتهٔ literal اشاره می‌کند؛ یعنی مقداری که مستقیماً داخل متن برنامه به‌صورت ثابت نوشته شده است. این متغیر از جایی که تعریف می‌شود تا انتهای محدودهٔ دسترسی (scope) فعلی معتبر است. در 4-1 با استفاده از کامنت‌ها مشخص شده که متغیر s در کدام بخش‌ها معتبر است.

```rust
    {                      // s هنوز معتبر نیست چرا که اینجا تعریف نشده است
        let s = "hello";   //  در این نقطه معتبر است

        // s ادامه کد و استفاده از 
    }                      // دیگر معتبر نیست s این بلوک به پایان رسیده و 
```

<span class="caption">4-1: یک متغیر و بازه ای که در آن معتبر است</span>

به عبارت ساده‌تر، اینجا همزمان دو نکته مهم وجود دارد:

* وقتی متغیر s وارد محدوده (scope) می شود، معتبر و قابل استفاده است.
* این متغیر تا وقتی که از محدوده خارج نشده، همچنان معتبر باقی می ماند.

در این مرحله، رابطه بین محدوده‌ها (scopes) و زمان معتبر بودن متغیرها تقریباً شبیه به چیزی است که در زبان‌های برنامه‌نویسی دیگر دیده‌ایم. حالا با این درک اولیه، سراغ معرفی نوع داده String و مفاهیم مرتبط با آن می رویم.

### نوع داده رشته (`String`)
<div dir = "rtl">
برای توضیح دادن قوانین مالکیت (ownership)، به یک نوع داده پیچیده‌تر از آن‌هایی که در بخش <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">انواع داده</a> فصل ۳ بررسی کردیم نیاز داریم.
انواع داده‌ای که قبلاً دیدیم همگی روی پشته (stack) ذخیره می‌شوند و وقتی محدودهٔ آن‌ها (scope) تمام می‌شود، از پشته حذف می‌گردند.
اما حالا می‌خواهیم به داده‌هایی نگاه کنیم که روی هیپ (heap) ذخیره می‌شوند و بررسی کنیم که راست (Rust) چطور تشخیص می‌دهد چه زمانی باید این داده‌ها را پاک‌سازی (آزاد) کند.
<p></p>
</div>


ما در اینجا از `String` به‌عنوان مثال استفاده می‌کنیم و روی بخش‌هایی از `String` تمرکز می‌کنیم که به مالکیت (ownership) مربوط می‌شوند. این ویژگی‌ها دربارهٔ سایر انواع دادهٔ پیچیده نیز صدق می‌کنند؛ چه آن‌هایی که توسط کتابخانهٔ استاندارد ارائه شده‌اند و چه آن‌هایی که خودتان ایجاد می‌کنید. دربارهٔ `String` با جزئیات بیشتری در فصل ۸ صحبت خواهیم کرد.


قبلاً با رشته های خام (litreral strings‌) آشنا شده‌ایم؛ جایی که مقدار رشته مستقیماً داخل برنامه نوشته (hardcode) می‌شود. string literalها راحت و کاربردی هستند، اما برای همهٔ موقعیت‌هایی که ممکن است بخواهیم از متن استفاده کنیم مناسب نیستند. یکی از دلایل این است که آن‌ها غیرقابل‌تغییر (immutable) هستند. دلیل دیگر این است که همهٔ مقادیر رشته‌ای را نمی‌توان هنگام نوشتن کد از قبل دانست؛ برای مثال، اگر بخواهیم ورودی کاربر را دریافت کرده و ذخیره کنیم چه؟

برای چنین شرایطی، Rust یک نوع رشتهٔ دوم به نام String دارد. این نوع روی هیپ (heap) تخصیص داده می‌شود و به همین دلیل می‌تواند مقداری از متن را ذخیره کند که اندازهٔ آن در زمان کامپایل برای ما مشخص نیست. شما می‌توانید با استفاده از تابع `from` یک `String` را از روی یک string literal ایجاد کنید، به این صورت:

```rust
let s = String::from("hello");
```

دو نقطهٔ دوتایی (`::`) یک اپراتور است که به ما اجازه می‌دهد تا تابع `from` را زیر نوع `String` نام‌گذاری کنیم، به جای اینکه از نامی مثل string_from استفاده کنیم.
این نحو بیشتر در بخش «روش استفاده از متدها (Method Syntax)» فصل ۵ و همچنین وقتی دربارهٔ نام‌گذاری با ماژول‌ها (namespacing with modules) در بخش «مسیرها برای ارجاع به یک آیتم در درخت ماژول» فصل ۷ صحبت می‌کنیم، توضیح داده خواهد شد.

مثالی از رشته که **میتواند** تغییر کند:

```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() یک مقدار خام به رشته پیوست میکند

    println!("{s}"); // را چاپ می کند `hello, world!`
```

پس تفاوت اینجاست: چرا String قابل تغییر است اما literalها نیستند؟
تفاوت به نحوهٔ مدیریت حافظه توسط این دو نوع داده برمی‌گردد.

### حافظه و تخصیص

در مورد string literal، ما محتوای آن را در زمان کامپایل می‌دانیم، بنابراین متن مستقیماً داخل فایل اجرایی نهایی قرار می‌گیرد. به همین دلیل string literalها سریع و بهینه هستند. اما این ویژگی‌ها فقط به دلیل غیرقابل تغییر بودن (immutability) آن‌هاست. متأسفانه، نمی‌توانیم برای هر متن با اندازه‌ای نامشخص در زمان کامپایل و قابل تغییر در زمان اجرا، حافظه‌ای داخل فایل باینری قرار دهیم.

با نوع دادهٔ `String`، برای پشتیبانی از یک متن قابل تغییر و قابل رشد، نیاز داریم تا مقدار حافظه‌ای روی هیپ (heap) تخصیص دهیم که اندازهٔ آن در زمان کامپایل مشخص نیست تا محتوا را در خود نگه دارد. این یعنی:


* حافظه باید در زمان اجرای برنامه از سیستم‌عامل درخواست شود.
- نیاز داریم راهی برای بازگرداندن این حافظه به سیستم‌عامل زمانی که دیگر به String نیاز نداریم داشته باشیم.



بخش اول توسط ما انجام می‌شود: وقتی `String::from` را صدا می‌زنیم، پیاده‌سازی آن حافظهٔ مورد نیازش را درخواست می‌کند. این روش تقریباً در همهٔ زبان‌های برنامه‌نویسی مشترک است.

اما بخش دوم متفاوت است. در زبان‌هایی که دارای جمع‌آورندهٔ زباله (Garbage Collector یا GC) هستند، GC حافظه‌ای که دیگر استفاده نمی‌شود را پیگیری و پاک می‌کند و نیازی نیست ما به آن فکر کنیم. بدون GC، مسئولیت ماست که تشخیص دهیم چه زمانی حافظه دیگر استفاده نمی‌شود و به‌طور صریح آن را آزاد کنیم، درست همان‌طور که حافظه را درخواست کرده‌ایم. انجام درست این کار به‌طور تاریخی یکی از مشکلات دشوار برنامه‌نویسی بوده است. اگر فراموش کنیم، حافظه هدر می‌رود. اگر زود انجام دهیم، متغیر نامعتبری خواهیم داشت. اگر دوبار انجام دهیم، این هم یک باگ است. بنابراین باید دقیقاً یک `allocate` با یک `free` جفت شود.
<div dir = "rtl">
Rust مسیر متفاوتی را انتخاب کرده است: حافظه به‌طور خودکار بازگردانده می‌شود وقتی متغیری که مالک آن است از محدودهٔ خود خارج شود.
در اینجا نسخه‌ای از مثال scope ما از لیست 4-1 را داریم که به جای string literal از String استفاده می‌کند:
</div>

```rust
    {
        let s = String::from("hello");   // s در این نقطه معتبر است

        // s ادامه کد و استفاده از 
    }                      // دیگر معتبر نیست s این بلوک به پایان رسیده و 
```

یک نقطهٔ طبیعی برای بازگرداندن حافظه‌ای که `String` ما استفاده می‌کند به سیستم‌عامل وجود دارد: زمانی که s از محدودهٔ خود خارج شود (goes out of scope). وقتی یک متغیر از محدودهٔ خود خارج می‌شود، Rust به‌طور خودکار یک تابع ویژه را صدا می‌زند. این تابع `drop` نام دارد و جایی است که نویسندهٔ `String` می‌تواند کد بازگرداندن حافظه را قرار دهد. Rust این تابع را به‌طور خودکار در بستن کروشهٔ بسته (closing curly bracket) صدا می‌زند.

> نکته: در C++، این الگو که منابع در پایان عمر یک آیتم آزاد می‌شوند، گاهی اوقات Resource Acquisition Is Initialization (RAII) نامیده می‌شود.
اگر قبلاً با الگوهای RAII کار کرده باشید، تابع `drop` در Rust برایتان آشنا خواهد بود.


این الگو تأثیر عمیقی بر نحوهٔ نوشتن کد در Rust دارد. ممکن است در حال حاضر ساده به نظر برسد، اما در موقعیت‌های پیچیده‌تر که بخواهیم چند متغیر از داده‌ای که روی هیپ تخصیص داده‌ایم استفاده کنند، رفتار کد می‌تواند غیرمنتظره باشد. بیایید حالا برخی از این موقعیت‌ها را بررسی کنیم.

#### راه‌های تعامل متغیرها با داده‌ها: جابجایی (Move)

چندین متغیر می‌توانند به روش‌های مختلف با یک داده در Rust تعامل داشته باشند.
بیایید یک مثال با یک عدد صحیح (integer) را در 4-2 بررسی کنیم.

```rust
    let x = 5;
    let y = x;
```

<span class="caption">4-2: اختصاص مقدار عددی متغیر `x`
به `y`</span>

می‌توانیم حدس بزنیم که این چه کاری انجام می‌دهد: «مقدار `5` را به `x` اختصاص بده؛ سپس یک کپی از مقدار `x` بساز و آن را به `y` اختصاص بده.»
حالا ما دو متغیر داریم، `x` و `y`، که هر دو برابر با `5` هستند. این دقیقاً همان چیزی است که رخ می‌دهد، زیرا اعداد صحیح مقادیر ساده‌ای با اندازهٔ مشخص و ثابت هستند و این دو مقدار `5` روی پشته (stack) قرار می‌گیرند.

حالا بیایید نسخهٔ String را بررسی کنیم:

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```

این کد خیلی شبیه کد قبلی به نظر می‌رسد، بنابراین ممکن است تصور کنیم که عملکردش همانند قبل است: یعنی خط دوم یک کپی از مقدار `s1` می‌سازد و آن را به `s2` اختصاص می‌دهد. اما این دقیقاً همان چیزی نیست که اتفاق می‌افتد.

به شکل 4-1 نگاه کنید تا ببینید زیر سطح چگونه با `String` رفتار می‌شود. یک `String` از سه بخش تشکیل شده است که در سمت چپ نشان داده شده‌اند: یک pointer به حافظه‌ای که محتوای رشته را نگه می‌دارد، یک length و یک capacity. این گروه از داده‌ها روی پشته (stack) ذخیره می‌شوند. در سمت راست، حافظهٔ روی هیپ (heap) است که محتوای واقعی رشته را نگه می‌دارد.
<div dir = "rtl">
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 70%;" />

<span class="caption">شکل 4-1: نمایش در حافظهٔ یک `String` که مقدار "hello" را نگه می‌دارد و به `s1` اختصاص یافته است.</span>

 این طول یا `length` نشان‌دهندهٔ میزان حافظه (بر حسب بایت) است که محتوای `String` در حال حاضر استفاده می‌کند.
capacity مقدار کل حافظه (بر حسب بایت) است که `String` از سیستم‌عامل دریافت کرده است. تفاوت بین `length` و `capacity` مهم است، اما در این زمینه فعلاً می‌توان آن را نادیده گرفت.

وقتی s1 را به s2 اختصاص می‌دهیم، داده‌های String کپی می‌شوند، یعنی pointer، `length` و `capacity` که روی پشته هستند، کپی می‌شوند. اما داده‌ای که pointer به آن روی هیپ اشاره می‌کند کپی نمی‌شود.

به عبارت دیگر، نمایش داده‌ها در حافظه مانند شکل 4-2 خواهد بود.

<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 70%;" />

<span class="caption">شکل 4-2: نمایش در حافظهٔ متغیر `s2` که یک کپی از pointer، length و capacity متغیر s1 دارد</span>

این نمایش شبیه شکل 4-3 **نیست**؛ شکل 4-3 نشان می‌دهد که حافظه چگونه به نظر می‌رسید اگر Rust داده‌های روی هیپ را هم کپی می‌کرد.
اگر Rust این کار را انجام می‌داد، عمل `s2 = s1` می‌توانست از نظر کارایی زمان اجرا (runtime performance) بسیار پرهزینه باشد، مخصوصاً اگر داده‌های روی هیپ بزرگ باشند.

<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 70%;" />

<span class="caption">شکل 4-3: یک حالت دیگر برای آنچه ممکن است `s2 = s1` انجام دهد اگر Rust داده‌های روی هیپ را هم کپی می‌کرد</span>
</div>

قبلاً گفتیم که وقتی یک متغیر از محدودهٔ خود خارج می‌شود، Rust به‌طور خودکار تابع `drop` را صدا می‌زند و حافظهٔ روی هیپ آن متغیر را آزاد می‌کند. اما شکل 4-2 نشان می‌دهد که هر دو pointer به همان موقعیت حافظه اشاره می‌کنند. این یک مشکل است: وقتی `s2` و `s1` از محدوده خارج شوند، هر دو تلاش می‌کنند همان حافظه را آزاد کنند. این خطا به نام double free شناخته می‌شود و یکی از باگ‌های امنیت حافظه است که قبلاً ذکر کردیم. آزاد کردن حافظه دوبار می‌تواند منجر به خرابی حافظه (memory corruption) شود که احتمالاً باعث آسیب‌پذیری امنیتی می‌شود.

برای اطمینان از ایمنی حافظه، Rust یک جزئیهٔ دیگر دارد: به جای اینکه تلاش کند حافظهٔ تخصیص‌یافته را کپی کند، Rust `s1` را دیگر معتبر نمی‌داند و بنابراین وقتی `s1` از محدوده خارج می‌شود، نیازی به آزاد کردن چیزی نیست.
وقتی بعد از ایجاد `s2` بخواهید از `s1` استفاده کنید، می‌بینید که کار نمی‌کند:



```rust,ignore,does_not_compile
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
```

شما یک خطا مانند این دریافت خواهید کرد، زیرا Rust مانع استفاده از ارجاع نامعتبر (invalidated reference) می‌شود:

```text
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

اگر هنگام کار با زبان‌های دیگر با اصطلاحات shallow copy و deep copy آشنا شده باشید، مفهوم کپی کردن pointer، length و capacity بدون کپی کردن داده‌ها احتمالاً شبیه به shallow copy به نظر می‌رسد.

اما در Rust، به دلیل اینکه متغیر اول نیز نامعتبر می‌شود (invalidated)، به جای اینکه آن را shallow copy بنامیم، این عمل move نامیده می‌شود.
در این مثال، می‌گوییم که `s1` به `s2` منتقل (moved) شده است.

پس آنچه در واقع رخ می‌دهد در شکل 4-4 نشان داده شده است.
<div dir="rtl">
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />

<span class="caption">شکل 4-4: نمایش در حافظه پس از اینکه `s1` نامعتبر شده است</span>
</div>

این مشکل ما را حل می‌کند! حالا که فقط `s2` معتبر است، وقتی از محدوده خارج شود، تنها خودش حافظه را آزاد می‌کند و کار تمام است.

علاوه بر این، یک انتخاب طراحی که از این رفتار نتیجه می‌شود این است که: Rust هیچ‌گاه به‌طور خودکار کپی عمیق (deep copy) از داده‌های شما ایجاد نمی‌کند. بنابراین، هرگونه کپی خودکار (automatic copying) را می‌توان از نظر کارایی زمان اجرا ارزان و کم‌هزینه فرض کرد.
#### راه‌های تعامل متغیرها با داده‌ها: Clone

اگر بخواهیم داده‌های هیپ (heap) یک String را به‌طور عمیق کپی کنیم، نه فقط داده‌های روی پشته (stack)، می‌توانیم از یک متد رایج به نام `clone` استفاده کنیم.
در فصل ۵ دربارهٔ نحو متدها (method syntax) صحبت خواهیم کرد، اما از آنجایی که متدها در بسیاری از زبان‌های برنامه‌نویسی رایج هستند، احتمالاً قبلاً با آن‌ها آشنا شده‌اید.

در اینجا یک مثال از استفادهٔ متد `clone` آورده شده است:

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
```

این کار به‌خوبی انجام می‌شود و به‌طور صریح رفتاری را ایجاد می‌کند که در شکل 4-3 نشان داده شده است، یعنی داده‌های روی هیپ (heap) واقعاً کپی می‌شوند.
وقتی یک فراخوانی به `clone` می‌بینید، می‌دانید که یک کد دلخواه اجرا می‌شود و این کد ممکن است پرهزینه باشد. این یک نشانهٔ بصری است که چیزی متفاوت در حال رخ دادن است.

#### داده‌های فقط روی پشته: رونویسی

یک نکتهٔ دیگر که هنوز دربارهٔ آن صحبت نکرده‌ایم وجود دارد. این کد که از اعداد صحیح استفاده می‌کند و بخشی از آن در لیست 4-2 نشان داده شد، درست کار می‌کند و معتبر است:

```rust
    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
```

اما این کد به نظر می‌رسد با آنچه تازه یاد گرفتیم تناقض دارد: ما فراخوانی `clone` نداریم، اما x هنوز معتبر است و به y منتقل (moved) نشده است.

دلیل این است که انواعی مانند اعداد صحیح که اندازهٔ مشخصی در زمان کامپایل دارند، به‌طور کامل روی پشته (stack) ذخیره می‌شوند، بنابراین کپی کردن مقادیر واقعی آن‌ها سریع است. این یعنی هیچ دلیلی وجود ندارد که بخواهیم مانع از معتبر بودن x پس از ایجاد متغیر y شویم. به عبارت دیگر، بین deep copy و shallow copy در اینجا تفاوتی وجود ندارد، پس فراخوانی `clone` تفاوتی ایجاد نمی‌کند و می‌توان آن را حذف کرد.
<div dir = "rtl">
Rust یک توضیح ویژه به نام trait Copy دارد که می‌توانیم روی انواعی مثل اعداد صحیح که روی پشته ذخیره می‌شوند قرار دهیم (در فصل ۱۰ بیشتر دربارهٔ traits صحبت خواهیم کرد). اگر یک نوع دارای trait Copy باشد، متغیر قدیمی پس از تخصیص هنوز قابل استفاده است. Rust اجازه نمی‌دهد یک نوع را با trait Copy علامت‌گذاری کنیم اگر آن نوع یا هرکدام از اجزای آن trait Drop را پیاده‌سازی کرده باشند. اگر نوعی نیاز به کاری خاص هنگام خروج مقدار از محدوده داشته باشد و ما annotation Copy را به آن اضافه کنیم، خطای زمان کامپایل دریافت می‌کنیم. برای یادگیری نحوهٔ افزودن annotation Copy به نوع خود، به بخش «Derivable Traits» در ضمیمه C مراجعه کنید.
</div>

پس چه نوع‌هایی `Copy` هستند؟ می‌توانید مستندات هر نوع را بررسی کنید، اما به‌طور کلی هر گروهی از مقادیر سادهٔ اسکالر می‌تواند `Copy` باشد، و هیچ چیزی که نیاز به تخصیص حافظه داشته باشد یا شکل خاصی از منابع باشد، `Copy` نیست.
برخی از نوع‌هایی که `Copy` هستند عبارت‌اند از:

- تمام انواع اعداد صحیح، مانند `u32`.
- نوع بولین bool با مقادیر `true` و `false`.
- تمام انواع اعشاری (floating point)، مانند `f64`.
- نوع کاراکتر char.
- تاپل‌ها، اگر فقط شامل نوع‌هایی باشند که خودشان نیز `Copy` هستند. برای مثال، (`i32`, `i32`) `Copy` است، اما (`i32`, `String`) نیست.

### Ownership and Functions

معناشناسی (semantics) هنگام ارسال مقدار به یک تابع مشابه ارسال مقدار به یک متغیر است. وقتی یک متغیر را به یک تابع می‌دهیم، همانند تخصیص مقدار (assignment)، یا منتقل (move) می‌شود یا کپی (copy) می‌گردد.

 4-3 یک مثال دارد با چند توضیح (annotation) که نشان می‌دهد متغیرها کجا وارد و خارج از محدوده (scope) می‌شوند.

<span class="filename">نام فایل: src/main.rs</span>

```rust
fn main() {
    let s = String::from("hello");  // s به داخل محدوده می آید

    takes_ownership(s);             // مقدار s به داخل تابع منتقل میشود...
                                    // ... بنابراین در اینجا دیگر معتبر نمی باشد

    let x = 5;                      // x به داخل محدوده می آید

    makes_copy(x);                  // از آنجایی که i32 trait `Copy` را پیاده‌سازی کرده است,
                                    // x منتقل (move)نمی‌شود به تابع، 
                                    // بنابراین بعد از تابع می‌توانیم از x استفاده کنیم.

} // اینجا x از محدوده خارج می‌شود، سپس s. با این حال، از آنجایی که مقدار s منتقل شده بود، 
  // اتفاق خاصی نمی‌افتد.

fn takes_ownership(some_string: String) { // some_string یه داخل محدوده می آید
    println!("{some_string}");
} // اینجا, some_string از محدوده خارج شده و `drop` فراخوانی میشود.
// حافظهٔ پشتیبان (backing memory) آزاد می‌شود.

fn makes_copy(some_integer: i32) { // some_integer به داخل محدوده می آید
    println!("{some_integer}");
} // اینجا, some_integer از محدوده خارج می شود. هیچ اتفاق خاصی رخ نمی دهد.
```

<span class="caption">4-3: توابع با توضیحات مربوط به مالکیت و محدوده (scope)</span>

اگر بعد از فراخوانی `takes_ownership` تلاش می‌کردیم از `s` استفاده کنیم، Rust یک خطای زمان کامپایل نشان می‌داد. این بررسی‌های ایستا (static checks) ما را از اشتباهات محافظت می‌کنند.

می‌توانید کدی به `main` اضافه کنید که از `s` و `x` استفاده می‌کند تا ببینید کجا می‌توان از آن‌ها استفاده کرد و کجا قوانین مالکیت مانع استفاده می‌شوند.

### مقدار بازگشتی و محدوده

بازگرداندن مقادیر از یک تابع نیز می‌تواند مالکیت (ownership) را منتقل کند.
 4-4 یک مثال است که دارای توضیحات مشابه 4-3 می‌باشد.

<span class="filename">نام فایل: src/main.rs</span>

```rust
fn main() {
    let s1 = gives_ownership();
    let s2 = String::from("hello"); 
    let s3 = takes_and_gives_back(s2); 
}
fn gives_ownership() -> String {
    let some_string = String::from("yours"); 

    some_string 
}
fn takes_and_gives_back(a_string: String) -> String {
    a_string  
}

```

<span class="caption">4-4: انتقال مالکیت مقادیر بازگشتی</span>

مالکیت یک متغیر همیشه از یک الگو پیروی می‌کند: اختصاص یک مقدار به متغیر دیگر باعث انتقال (`move`) آن می‌شود. وقتی متغیری که شامل داده‌ای روی هیپ است از محدوده خارج شود، مقدار توسط drop پاک می‌شود، مگر اینکه داده به متغیر دیگری منتقل شده و مالکیت آن به آن متغیر داده شده باشد.

استفاده از مالکیت و سپس بازگرداندن مالکیت با هر تابع کمی خسته‌کننده است. اگر بخواهیم یک تابع از مقداری استفاده کند اما مالکیت آن را نگیرد چه کنیم؟ واقعاً آزاردهنده است که هر چیزی که می‌فرستیم، اگر بخواهیم دوباره استفاده کنیم، باید برگردانده شود، علاوه بر داده‌هایی که ممکن است از بدنهٔ تابع بخواهیم بازگردانیم.

می‌توان با استفاده از تاپل (`tuple`) چند مقدار را بازگرداند، همان‌طور که در  4-5 نشان داده شده است.

<span class="filename">نام فایل: src/main.rs</span>

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() طول یک رشته را بر میگرداند

    (s, length)
}
```

<span class="caption">4-5: بازگرداندن مالکیت پارامترها</span>

اما این روش برای مفهومی که باید رایج باشد، خیلی پرزحمت و زمان‌بر است. خوشبختانه Rust یک ویژگی برای استفاده از مقدار بدون انتقال مالکیت دارد: **ارجاعات** (**references**).

